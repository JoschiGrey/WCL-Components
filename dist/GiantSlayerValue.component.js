/*!
 * Created using the WCL-TS-Components Template https://github.com/JoschiGrey/WCL-TS-Components
 * The source code can be found here https://github.com/JoschiGrey/WCL-Components
 *
 */
let getComponent;(()=>{"use strict";var t={d:(e,i)=>{for(var s in i)t.o(i,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:i[s]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};function i(t,e){return{component:"EnhancedMarkdown",props:{content:`\n<u># ${t} Error</u>\n${e}\n`}}}t.d(e,{default:()=>g});const s=(t,e)=>{for(const i of e)for(const e in i)if(t[e]!==i[e])return!0};class r{constructor(t,e={}){this.actors={};for(const i of t){if(!i.ability||!i.target||!i.source)continue;if(i.type.includes("stack"))continue;if("Pet"===i.target.type)continue;if("friendly"!==i.targetDisposition)continue;if(e.auraIds&&!e.auraIds.has(i.ability.id))continue;if(e.fight&&e.fight.isEventExcludedFromDamageRankings(i))continue;if(e.targetFilters&&s(i.target,e.targetFilters))continue;if(e.sourceFilters&&s(i.source,e.sourceFilters))continue;if(e.abilityFilters&&s(i.ability,e.abilityFilters))continue;const t=new n(i.source.id),r=new o(i.target.id),d=new a(i.ability.id);i.type.includes("apply")?this.addActor(t).addTarget(r).addBuff(d).buffApplied(i,e.captureEvent):i.type.includes("remove")&&this.addActor(t).addTarget(r).addBuff(d).buffRemoved(i,e.captureEvent)}}addActor(t){return this.actors[t.id]?this.actors[t.id]:(this.actors[t.id]=t,t)}getAurasBySourceActor(t){if(this.actors[t])return this.actors[t]}getSelfBuff(t,e){return this.actors[t].targets[t].buffs[e]}}class n{constructor(t){this.targets={},this.id=t}addTarget(t){return this.targets[t.id]?this.targets[t.id]:(this.targets[t.id]=t,t)}}class o{constructor(t){this.buffs={},this.id=t}addBuff(t){return this.buffs[t.id]?this.buffs[t.id]:(this.buffs[t.id]=t,t)}}class a{constructor(t){this.applied=[],this.removed=[],this.events={},this.id=t}buffApplied(t,e=!1){this.applied.push(t.timestamp),e&&(this.events[t.timestamp]=t)}buffRemoved(t,e=!1){this.removed.push(t.timestamp),e&&(this.events[t.timestamp]=t)}get appliedTimings(){return this.applied}get removedTimings(){return this.removed}get sortedTimeSpans(){if(this._sortedTimes)return JSON.parse(JSON.stringify(this._sortedTimes));for(this.applied=Array.from(new Set(this.applied)),this.removed=Array.from(new Set(this.removed));this.applied.length<this.removed.length;)this.applied.unshift(0);for(this.applied.sort(((t,e)=>t-e));this.removed.length<this.applied.length;)this.removed.push(1/0);return this.removed.sort(((t,e)=>t-e)),this._sortedTimes=Array.from(Array(Math.max(this.applied.length,this.removed.length)),((t,e)=>[this.applied[e]?this.applied[e]:0,this.removed[e]?this.removed[e]:1/0])),JSON.parse(JSON.stringify(this._sortedTimes))}isTimeInTimeSpans(t){let e=0,i=this.sortedTimeSpans.length-1;for(;e<=i;){const s=Math.floor((e+i)/2),[r,n]=this.sortedTimeSpans[s];if(t>=r&&t<=n)return!0;t<r?i=s-1:e=s+1}return!1}}class d{constructor(t){this.timeSpans=t.sortedTimeSpans,this.currentTimeSpan=this.timeSpans.shift()}isInTimeSpan(t){if(!this.currentTimeSpan)return!1;let e=this.currentTimeSpan[0];null!=e||(e=0);let i=this.currentTimeSpan[1];return null!=i||(i=1/0),t>i?(this.currentTimeSpan=this.timeSpans.shift(),this.isInTimeSpan(t)):t>=e&&t<=i}}function c(t,e,i){return t.eventsByCategoryAndDisposition(e,i)}const u="Master: Giant Slayer Value",h=375087,l={},f=new Set([361500,370452,357212,357209,359077,356995,362969,353759,1,368847,382411]),p=357210,m=new class{constructor(){this.messages=[]}addMessage(t,e){this.messages.push({name:e})}},g=getComponent=()=>{if(1!==reportGroup.fights.length)return i(u,"Please select a single fight");const t=reportGroup.fights[0];if(0===t.combatantInfoEvents.length)return i(u,"Sadly this component relies on real encounters and won't work with trash fights.");if(1!==t.combatantInfoEvents.length)return i(u,"Please select a single <Evoker>Devastation Evoker</Evoker>");const e=t.combatantInfoEvents[0].source;if(!e||"Devastation"!==t.specForPlayer(e))return i(u,"Please select a single <Evoker>Devastation Evoker</Evoker>");const s=c(t,"aurasGained","friendly"),n=new r(s,{sourceFilters:[{idInReport:e.idInReport}],auraIds:new Set([h])}),o=function(t,e,i){if(!e.source)throw new Error("Combatant Source was missing");const s=i.getSelfBuff(e.source.idInReport,h),r=new d(s);m.addMessage("dragonRageBuff",s.sortedTimeSpans);const n=[];for(const i of t){if(!i.source||!i.ability||!i.targetResources)continue;if(i.source.idInReport!==e.source.idInReport)continue;if(!i.amount)continue;if(!f.has(i.ability.id))continue;const t=i.targetResources.hitPoints/i.targetResources.maxHitPoints,s=i.ability.id===p,o=i.amount,a=r.isInTimeSpan(i.timestamp);n.push({healthPercent:t,damageDone:o,hasDragonrage:a,isDeepBreath:s,timestamp:i.timestamp})}return n}(c(t,"damage","friendly"),t.combatantInfoEvents[0],n);m.addMessage("damageSummaries",o);let a=0,l=0;for(const e of o)y(t.combatantInfoEvents[0])&&(e.hasDragonrage||e.isDeepBreath)?a+=1:a+=e.healthPercent,l+=e.healthPercent;l/=o.length;const g=(100*l).toFixed(2);m.addMessage("averageMasteryValue",l),a/=o.length;const v=(100*a).toFixed(2);m.addMessage("averageMasteryValueWithTyranny",l);const b=t.combatantInfoEvents[0].stats.mastery/72+22.5,S=b.toFixed(2),I=(l*b).toFixed(2),T=(a*b).toFixed(2);return{component:"EnhancedMarkdown",props:{content:`\n# <u>${u} for <Evoker>${e.name}</Evoker></u>\nOn average ${v}% (${g}% without <AbilityIcon id={376888} icon="ability_evoker_dragonrage2.jpg">Tyranny</AbilityIcon>) of <AbilityIcon id={362980} icon="ability_evoker_masterygiantkiller.jpg">Mastery: Giant Slayer</AbilityIcon> got applied.\n\nWith your Mastery of ${S}% this was an overall DPS gain of ${T}% (${I}%), assuming your mastery did not change during the Encounter\n`}}};function y(t){if(!t.source)throw new Error("Combatant Info Event was incomplete");if(l[t.source.idInReport])return l[t.source.idInReport];const e=t.talentTree.find((t=>376888===t.spellId));return l[t.source.idInReport]=!!e,l[t.source.idInReport]}globalThis.getComponent=e.default})();